# -*- coding: utf-8 -*-
"""taquinP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16WpsCKvWeO0A1D1ozUmgGN5sfaHAKR93

## Intelligence artificielle et raisonnement TP1

Considérons le jeu du taquin suivant où il s’agit  de passer de l’état initial (à gauche) à l’état final (à droite)
"""

from IPython import display
display.Image("jeu_taquin.png")

"""En utilisant le langage Python, on vous demande de :

    1. Coder de manière générique les états, les actions, la fonction de transition d’états, l’état initial et les états finaux d’un problème de recherche dans un graphe d’états.
"""

class Taquin:
    def __init__(self, initial_state):
        self.state = initial_state

    def __str__(self):
        return "\n".join([" ".join(map(str, row)) for row in self.state])

    def find_empty_tile(self):
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 0:
                    return i, j

    def move(self, direction):
        empty_tile_row, empty_tile_col = self.find_empty_tile()

        if direction == 'up':
            new_row = empty_tile_row - 1
            new_col = empty_tile_col
        elif direction == 'down':
            new_row = empty_tile_row + 1
            new_col = empty_tile_col
        elif direction == 'left':
            new_row = empty_tile_row
            new_col = empty_tile_col - 1
        elif direction == 'right':
            new_row = empty_tile_row
            new_col = empty_tile_col + 1
        else:
            return False  # Invalid movement

        # Vérification des limites pour s'assurer que le mouvement est valide
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            # Échange des positions de la tuile vide et de la tuile adjacente
            self.state[empty_tile_row][empty_tile_col], self.state[new_row][new_col] = \
                self.state[new_row][new_col], self.state[empty_tile_row][empty_tile_col]
            return True
        else:
            return False
    def is_goal(self):
        # Vérifie si la configuration actuelle est le but (puzzle résolu)
        return self.state == [[0,1, 2], [3, 4, 5], [6, 7,8]]

# Define the initial state
initial_state = [[1, 4, 2], [3, 7, 0], [6, 8, 5]]

# Initialize taquin
taquin = Taquin(initial_state)

# Print the initial state
print("Initial State:")
print(taquin)

# Move the tile in different directions
taquin.move('up')  # Move the empty tile up
print("\nAfter moving up:")
print(taquin)

taquin.move('left')  # Move the empty tile left
print("\nAfter moving left:")
print(taquin)

taquin.move('down')  # Move the empty tile down
print("\nAfter moving down:")
print(taquin)

taquin.move('right')  # Move the empty tile right
print("\nAfter moving right:")
print(taquin)

"""2. Coder de manière générique les algorithmes :
        a. Recherche en profondeur limitée
        b. Recherche par profondeur itérative
        c. Recherche A*

#### Recherche par profondeur limitée
"""

movement_count = 0

def limited_depth_search(node, depth_limit, visited=None, open_set=None):
    if visited is None:
        visited = set()

    if open_set is None:
        open_set = set()

    if node.is_goal():
        visited.add(tuple(map(tuple, node.state)))
        print("Solution found:")
        print(node)
        print("Number of visited nodes is:", len(visited))
        return True, len(visited), open_set

    if depth_limit == 0 or tuple(map(tuple, node.state)) in visited:
        visited.add(tuple(map(tuple, node.state)))
        return False, len(visited), open_set

    visited.add(tuple(map(tuple, node.state)))
    open_set.add(tuple(map(tuple, node.state)))

    for direction in ['up', 'left', 'down', 'right']:
        new_node = Taquin([row[:] for row in node.state])
        if new_node.move(direction):
            print(f"Moving {direction}:")
            print(new_node)

            global movement_count
            movement_count += 1
            print(f"Movement count: {movement_count}")
            result, visited_count, open_set = limited_depth_search(new_node, depth_limit - 1, visited, open_set)
            if result:
                return True, visited_count, open_set

    return False, len(visited), open_set

"""*Exécution*


"""

depth_limit = 5  #  the desired depth limit
result, visited_count, open_set = limited_depth_search(taquin, depth_limit)
print("Total number of visited nodes:", visited_count)
print("Open set:",  len(open_set),open_set)

"""#### Recherche par profondeur itérative"""

def iterative_depth_search(taquin):
    nb_total_visited_states = 0
    max_depth = 1
    total_open_set = set()

    while True:
        result, visited_count, open_set = limited_depth_search(taquin, max_depth)
        nb_total_visited_states += visited_count
        total_open_set.update(open_set)

        if result:
            print("Total number of visited nodes:", nb_total_visited_states)
            print("Total open set:",total_open_set)
            return nb_total_visited_states, total_open_set

        max_depth += 1

"""*Exécution*


"""

print(iterative_depth_search(taquin))

"""#### Recherche A*

3. Instancier avec le problème du Taquin en utilisant 2 heuristiques admissibles vues en cours
"""

from copy import deepcopy

def heuristic_h1(state):
    # Misplaced tiles heuristic
    goal_state = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
    misplaced = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != goal_state[i][j]:
                misplaced += 1
    return misplaced

def heuristic_h2(state):
    goal_state = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
    h2 = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                row, col = divmod(state[i][j] - 1, 3)
                h2 += abs(row - i) + abs(col - j)
    return h2

def a_star_search(taquin, heuristic):
    start_node = taquin
    closed_set = set()
    open_set = [(0, start_node, [])]
    number_movement = 0
    visited_nodes = set()
    max_open_set_size = 0  # Counter for the maximum open set size

    while open_set:
        open_set.sort(key=lambda item: item[0])
        current_priority, node, path = open_set.pop(0)

        # Update the maximum open set size
        max_open_set_size = max(max_open_set_size, len(open_set) + 1)

        if str(node.state) not in visited_nodes:
            visited_nodes.add(str(node.state))

        if node.is_goal():
            result = deepcopy(taquin)
            for direction in path:
                result.move(direction)
                print(result)
                print("\n")
            print("Number of visited nodes (A*):", len(visited_nodes))
            print("Maximum open set size (A*):", max_open_set_size)
            return path, len(visited_nodes), max_open_set_size

        closed_set.add(str(node.state))
        for direction in ["up", "down", "left", "right"]:
            child = deepcopy(node)
            child.move(direction)
            print("After moving", direction, ":")
            number_movement += 1
            print("Movement number:", number_movement)
            print(child, "\n")

            if str(child.state) not in closed_set and str(child.state) not in visited_nodes:
                open_set.append((len(path) + heuristic(child.state), child, path + [direction]))

    return None, None, None

"""*Exécution*


"""

a_star_search(taquin, heuristic_h1)
a_star_search(taquin, heuristic_h2)

"""# **Improvment A***

In this modification, the variable `last_move` is used to store the last movement. When generating child nodes, it checks if the opposite movement is being attempted and skips that iteration if necessary. This way, it avoids making the reverse move in consecutive steps.
"""

def a_star_search_improved(taquin, heuristic):
    start_node = taquin
    closed_set = set()
    open_set = [(0, start_node, [])]
    number_movement = 0
    visited_nodes = set()
    last_move = None  # Initialize the last move variable

    while open_set:
        open_set.sort(key=lambda item: item[0])
        _, node, path = open_set.pop(0)

        if str(node.state) not in visited_nodes:
            visited_nodes.add(str(node.state))

        if node.is_goal():
            result = deepcopy(taquin)
            for direction in path:
                result.move(direction)
                print(result)
                print("\n")
            print("Number of visited nodes is:", len(visited_nodes))
            return path

        closed_set.add(str(node.state))
        for direction in ["up", "down", "left", "right"]:
            if (last_move == "up" and direction == "down") or \
               (last_move == "down" and direction == "up") or \
               (last_move == "left" and direction == "right") or \
               (last_move == "right" and direction == "left"):
                continue  # Avoid moving in the opposite direction

            child = deepcopy(node)
            child.move(direction)
            print("After moving", direction, ":")
            number_movement += 1
            print("Movement number:", number_movement)
            print(child, "\n")

            estimated_cost = len(path) + heuristic(child.state)
            if str(child.state) not in closed_set and str(child.state) not in visited_nodes :
                open_set.append((estimated_cost, child, path + [direction]))

        # Save the last movement
        if path:
            last_move = path[-1]

    return None

"""*Exécution*


"""

a_star_search_improved(taquin, heuristic_h2)

"""4. Comparer les algorithmes à l’aide d’un graphique :  nombre de nœuds traités, taille maximale de la liste des nœuds candidats (ouverts)

**Limited depth search :**

The total number of nodes explored in the worst case is given by the formula:

![Capture d'écran 2023-11-14 235452.png](data:image/png;base64,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)

the open set's maximum size would be the number of nodes at the last level of the search tree. This corresponds to:

![Capture d'écran 2023-11-14 235851.png](data:image/png;base64,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)


*with d being the depth limit and b being the branchement factor (here b=4)*

**Iterative depth search :**

The total number of nodes explored in the worst case is given by the formula:


![Capture d'écran 2023-11-15 000140.png](data:image/png;base64,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)

the maximum size of the open set in each iteration is:

![image.png](data:image/png;base64,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)

*with D being the depth of the optimal solution and b being the branchement factor (here b=4)*

 **A* search :**


the maximum size of the open set in each iteration is:


![Capture d'écran 2023-11-14 235851.png](data:image/png;base64,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)

the open set's maximum size would be approximately:


![Capture d'écran 2023-11-14 235851.png](data:image/png;base64,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)

*with d being the depth of the optimal solution and b being the branchement factor (here b=4)*

**Comparaison des algorithmes avec taquin 3*3**
"""

# Example of taquin 3*3
initial_state = [[1, 4, 2], [3, 7, 5], [6, 8, 0]]
taquin = Taquin(initial_state)

# Run iterative_depth_search to get the data for the plot
visited_iterative, open_set_iterative = iterative_depth_search(taquin)

# Run limited_depth_search separately to get its data
result_limited, visited_limited, open_set_limited = limited_depth_search(taquin, 5)

path_a_star, visited_a_star, max_open_set_a_star = a_star_search(taquin, heuristic_h1)
path_a_star2, visited_a_star2, max_open_set_a_star2 = a_star_search(taquin, heuristic_h1)

import matplotlib.pyplot as plt
import numpy as np
# Plotting
fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

# Plot for iterative_depth_search
ax[0].plot(np.arange(1, visited_iterative + 1), label='Visited States (Iterative DFS)', color='blue')
ax[0].set_ylabel('Number of Visited States')
ax[0].legend()

ax[1].plot(np.arange(1, len(open_set_iterative) + 1), label='Open Set (Iterative DFS)', color='green')
ax[1].set_xlabel('Step')
ax[1].set_ylabel('Number of States in Open Set')
ax[1].legend()

# Plot for limited_depth_search
fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

ax[0].plot(np.arange(1, visited_limited + 1), label='Visited States (Limited DFS)', color='red')
ax[0].set_ylabel('Number of Visited States')
ax[0].legend()

ax[1].plot(np.arange(1, len(open_set_limited) + 1), label='Open Set (Limited DFS)', color='orange')
ax[1].set_xlabel('Step')
ax[1].set_ylabel('Number of States in Open Set')
ax[1].legend()

# Plot for A* search for heuristic h1
fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

ax[0].plot(np.arange(1, visited_a_star + 1), label='Visited States (A*) heuristic h1', color='purple')
ax[0].set_ylabel('Number of Visited States')
ax[0].legend()

ax[1].plot(np.arange(1, max_open_set_a_star + 1), label='Max Open Set Size (A*) heuristic h1', color='brown')
ax[1].set_xlabel('Step')
ax[1].set_ylabel('Maximum Number of States in Open Set')
ax[1].legend()
# Plot for A* search for heuristic h2
fig, ax = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

ax[0].plot(np.arange(1, visited_a_star2 + 1), label='Visited States (A*) heuristic h2', color='purple')
ax[0].set_ylabel('Number of Visited States')
ax[0].legend()

ax[1].plot(np.arange(1, max_open_set_a_star2 + 1), label='Max Open Set Size (A*) heuristic h2', color='brown')
ax[1].set_xlabel('Step')
ax[1].set_ylabel('Maximum Number of States in Open Set')
ax[1].legend()


plt.show()

"""    5. Augmenter la taille du jeu du Taquin (4x4, 7x7, 10x10). Comparer les algorithmes en fonction de l’évolution de la taille."""

import random

class Taquin2:
    def __init__(self, initial_state):
        self.state = initial_state
        self.n = len(initial_state)

    def __str__(self):
        return "\n".join([" ".join(map(str, row)) for row in self.state])

    def find_empty_tile(self):
        for i in range(self.n):
            for j in range(self.n):
                if self.state[i][j] == 0:
                    return i, j

    def move(self, direction):
        empty_tile_row, empty_tile_col = self.find_empty_tile()

        if direction == 'up':
            new_row = empty_tile_row - 1
            new_col = empty_tile_col
        elif direction == 'down':
            new_row = empty_tile_row + 1
            new_col = empty_tile_col
        elif direction == 'left':
            new_row = empty_tile_row
            new_col = empty_tile_col - 1
        elif direction == 'right':
            new_row = empty_tile_row
            new_col = empty_tile_col + 1
        else:
            return False  # Invalid movement

        if 0 <= new_row < self.n and 0 <= new_col < self.n:
            self.state[empty_tile_row][empty_tile_col], self.state[new_row][new_col] = \
                self.state[new_row][new_col], self.state[empty_tile_row][empty_tile_col]
            return True
        else:
            return False

    def is_goal(self):
        return self.state == [[i * self.n + j for j in range(self.n)] for i in range(self.n)]

    def shuffle(self):
        goal = [[i * self.n + j for j in range(self.n)] for i in range(self.n)]
        flat_goal = [num for row in goal for num in row]

        flat_state = random.sample(flat_goal, len(flat_goal))
        self.state = [flat_state[i:i+self.n] for i in range(0, len(flat_state), self.n)]


# Example of usage
n = 5  # You can change this to create an n x n grid
initial_state = [[i * n + j for j in range(n)] for i in range(n)]
taquin = Taquin2(initial_state)

print("Initial State:")
print(taquin)

taquin.shuffle()

print("\nAfter shuffling:")
print(taquin)

"""Increasing the value of \(n\) in Limited Depth Search results in a more constrained search due to the depth parameter. However, if the depth is not appropriately set, Limited Depth Search may overlook the solution, making it inefficient for extensive search spaces.

Iterative Deepening Search, while attempting to address limitations, can still prove inefficient for large search spaces due to the redundant exploration of nodes at different depths.

On the other hand, A* emerges as a comprehensive and optimal algorithm, particularly when employing an admissible and consistent heuristic. Its intelligent exploration of the search space emphasizes more promising paths.

In scenarios involving small-sized puzzles or puzzles with relatively shallow solutions, Limited Depth Search or Iterative Deepening Search might suffice. However, for larger puzzles or situations where efficiency is paramount, A* with a well-designed heuristic is often the preferred choice. Its ability to intelligently guide the search potentially leads to the exploration of fewer nodes.
"""